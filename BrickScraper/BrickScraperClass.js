/************************************************************************************* 
/ Author: Daniel Hearn
/ Email: daniel.hearn@gmail.com
/ Date: 5 September 2024
/
/ Description:
/     Web scraper for parsing BrickLink.com catalog item inventory pages into a 
/     hierarchical data structure along with functions to output the data structure
/     into various human and machine readable forms.
/*************************************************************************************/


/************************************************************************************* 
/ BrickScraper
/ Class for storing and parsing an item's bricklink part list
/*************************************************************************************/
class BrickScraper {

  /** Constructor **/
  constructor() {
    // The scraper maintains a flattened list of items. This list facilitates 
    // serialization by removing circular dependencies and is also used to 
    // represent the data in google sheets.
    this.items = new BrickItems();
    
    // This array of BrickItem is used to store the roots as they are created and
    // parsed. It is not of type BrickItems, because we want to avoid the caching
    // behavior of that class.
    this.roots = [];
  }

  /************************************************************************************* 
  / toMarkdown
  /*************************************************************************************/
  toMarkdown() {
    const date = new Date();
    
    return [
      `# Inventory Overview\n`,
      `This inventory has ${this.items.totalInstances()} items, including:\n\n`,

      `- ${this.items.filter((item) => item.type == BrickTypes.typeEnum.SET).totalInstances()} set(s).\n`,
      `- ${this.items.filter((item) => item.type == BrickTypes.typeEnum.PART).totalInstances()} part(s).\n`,
      `- ${this.items.filter((item) => item.type == BrickTypes.typeEnum.MINIFIG).totalInstances()} minifig(s).\n`,
      `- ${this.items.filter((item) => item.type == BrickTypes.typeEnum.BOOK).totalInstances()} book(s).\n`,
      `- ${this.items.filter((item) => item.type == BrickTypes.typeEnum.GEAR).totalInstances()} pieces(s) of gear.\n\n`,

      ...(BrickItems.toMarkdownByType(this.items, BrickTypes.typeEnum.SET)),
      ...(BrickItems.toMarkdownByType(this.items, BrickTypes.typeEnum.PART)),
      ...(BrickItems.toMarkdownByType(this.items, BrickTypes.typeEnum.MINIFIG)),
      ...(BrickItems.toMarkdownByType(this.items, BrickTypes.typeEnum.GEAR)),
      ...(BrickItems.toMarkdownByType(this.items, BrickTypes.typeEnum.BOOK)),

      `This inventory was last updated on ${date.toDateString()} at ${date.toTimeString()}.\n\n`,

      `*This document was automatically generated by BrickScraper, an open source tool for creating and managing your personal LEGO inventory.*\n\n`,

      `*See \<GitHub URL\> or contact [Daniel Hearn](mailto:daniel.hearn@gmail.com) for more information.*\n\n`,
    ].join('');
  }

  /************************************************************************************* 
  / getJSON
  /*************************************************************************************/
  saveAsJSON() {
    // Copy over all of the properties to a clean object
    const safeObj = {...this};

    // Convenience property for serializing and parsing this class as JSON
    safeObj.jsonType = this.constructor.name;
    
    return JSON.stringify({scraper: safeObj, jsonType: "Top"}, null, 4);
  }

  /************************************************************************************* 
  / fromJSON
  /*************************************************************************************/
  static loadFromJSON(json) {
    function reviver(key, value) {
      let brickClass = {};
      
      if (value != null && typeof value == 'object') {
        if (value.jsonType == "Top") {
          // key-value pairs are properties of the soon-to-be BrickScraper (a.k.a "this").
          brickClass = new BrickScraper();
          brickClass.items = new BrickItems(...value.scraper.items);
          
          for (const [i, r] of value.scraper.roots.entries()) {
            const index = brickClass.items.findIndex((item) => {
              return item.idString == r.idString;
            });

            if (index >= 0) { // Found in array, so add the root to roots     
              brickClass.roots[i] = brickClass.items[index];
            } else { // Not found in array, so deserialization has gone wrong :(
              throw ("error deserializing JSON, root item not found");
            }
          }

          for (const instToRestore of brickClass.items.allInstances().values()) {
            if (instToRestore.jsonParentInst != null) {
              // find the parent inst in allInstances
              instToRestore.parentInst = brickClass.items.allInstances().find((inst) => {inst.idString == instToRestore.jsonParentInst});
            }
            // delete the jsonParentInst property
            delete instToRestore.jsonParentInst;
            
            if (instToRestore.jsonChildrenInst != []) {
              // find the child inst in allInstances
              for (const childInst of instToRestore.jsonChildrenInst.values()) {
                instToRestore.childrenInst.push(brickClass.items.allInstances().find((inst) => {inst.idString == childInst}));
              }
            }
            // delete the jsonParentInst property
            delete instToRestore.jsonChildrenInst;
          }
            
          return brickClass;
        
        } else if (value.jsonType == "BrickItem") { //BrickItems
          // key-value pairs are array elements of the soon-to-be BrickItems (a.k.a "this").
          // all values in the array must be converted back to type BrickItem.
          brickClass = new BrickItem({
            num: value.num,
            color: value.color,
            type: value.type,
            commOpts:{category:value.category, description:value.description, itemUrl: value.itemUrl}
          });

          // Restore object references between the item and its instances
          brickClass.instances = new BrickItemInstances(...value.instances);
          for (const instToRestore in brickClass.instances.values()) {
            instToRestore.commonItem = brickClass;
            
            // delete the jsonCommonItem property
            delete instToRestore.jsonChildrenInst;
          }

          return brickClass;
        
        } else if (value.jsonType == "BrickItemInstance") { //BrickItemInstances
          // key-value pairs are array elements of the soon-to-be BrickItemInstances (a.k.a "this").
          // all values in the array must be converted back to type BrickItemInstance.
          brickClass = new BrickItemInstance();        
          
          // cache the string IDs, and clear the properties which will actually hold references to the objects.
          // the properties will be restored later.
          brickClass.jsonCommonItem = value.commonItem;
          brickClass.commonItem = null;
          brickClass.jsonParentInst = value.parentInst;
          brickClass.parentItem = null;
          brickClass.jsonChildrenInst = value.childrenInst;
          brickClass.childrenInst = new BrickItemInstances();

          for (const key of ['section', 'expectQty', 'haveQty', 'hidden', 'notes']) {
            brickClass[key] = value.hasOwnProperty(key) ? value[key] : brickClass[key];
          }

          return brickClass;
        } else {
          return value;
        }
      } else {
        return value;
      }
    };

    return JSON.parse(json, reviver);
  }

  /************************************************************************************* 
  / Scrapes the inventory page of every item in the roots list
  /*************************************************************************************/
  scrapeUrl (urls) { 
    // We'll use a normal array here. We don't want to check cache hits yet.
    const roots = [];
    
    urls.forEach((url) => {roots.push(new BrickItem({url:url}))});

    roots.forEach((root) => {
      let numItems = this.items.totalInstances();
      
      if (!this.items.push(root)) {
        for (let i = 0; i < root.numInstances; i++) {
          this.scrapeInst(root.instances[i]);
        }
      }

      this.roots.push(root);
    });

    return roots;
  }

  /************************************************************************************* 
  / Primary method for scraping the inventory page of an item
  /*************************************************************************************/
  // TODO: instrument this method with the class' log.
  scrapeInst (parentInst = null) {

    _scrapeInst(this, parentInst);

    /** Scrapes an item row into a new BrickItem **/
    function _scrapeItemRow(scraper, row, rowLocation, parentInst) {
      let found = false;
      
      // All table rows with inventory items have a <ITEM_NUM>.IV_ITEM class. If the current row
      // matches the '.IV_ITEM' filter, we must have an item row.
      if (row.filter('.IV_ITEM').length == 1) {
        let cols = row.children('*');
        let col = {};
        let props = {}

        // Add meta-info
        props.section = rowLocation.section;

        // Scrape info out of the item number column
        col = cols.eq(BrickTypes.inventoryColumns.get("ITEM_NO"));
        props.itemUrl = `https://www.bricklink.com${col.find('a').first().prop('href').concat().trim()}`;
        props.invUrl = col.find('a').last().text().toLowerCase() == 'inv';
        props = {...(ItemInfoFromUrl(props.itemUrl)), ...props};

        // Scrape info out of the qty column
        col = cols.eq(BrickTypes.inventoryColumns.get("QTY"));
        props.quantity = Number(col.text().trim());

        // Scrape description and category info
        col = cols.eq(BrickTypes.inventoryColumns.get("DESCRIPTION"));
        props.description = col.find('b').text().trim();

        // Category is always of the form "Catalog: Parts: Sub1: ... Subn".
        // We'll skip the first two, since they are set automatically when creating brick item.
        const catStrings = [];
        const cats = col.find('font.fv > a');
        for (let k = 2; k < cats.length; k++) {
          catStrings.push(cats.eq(k).text());
        }
        props.category = catStrings;

        // Validate properties
        // TODO: add more checks
        if (props.type !== rowLocation.type) {
          throw `Type match error while parsing "${itemUrl}"`;
        }

        // Each item will get added to the parent as a child item, which will 
        // automatically create a link back to its parent.
        const newItem = new BrickItem({
          num:props.num, 
          color:props.color, 
          type:props.type,
          commOpts:{category:props.category, description:props.description, itemUrl: props.itemUrl},
          instOpts:[{section:props.section, expectQty:props.quantity, haveQty:props.quantity, parentInst: parentInst}]
        });

        // Pushing the new item onto the itemlist will merge the new child with existing
        // items if needed. If the item was merged, push returns true to indicate that
        // it does not need to be scraped. If it returns false, the new item will only
        // be scraped if it had an inventory url in its item row.
        if (!scraper.items.push(newItem) && props.invUrl) {
          scraper.scrapeInst(newItem.instances[0])
        }
        
        // Indicate that we found an item, so the table row does not need to be scraped for headers.
        found = true;
      }
      return found;
    }

    /** Scrapes the headers from non-item rows **/
    function _scrapeHeader(row, rowLocation, headerType) {
      let found = false;
      let headers = null;
      if (headerType === BrickTypes.inventorySections) headers = BrickTypes.inventorySections;
      if (headerType === BrickTypes.inventoryItemTypes) headers = BrickTypes.inventoryItemTypes;
      
      headers.forEach((val, key) => {
        if (row.find(`td > font > b:contains(${key})`).length > 0) {
          if (headerType === BrickTypes.inventorySections) rowLocation.section = val;
          if (headerType === BrickTypes.inventoryItemTypes) rowLocation.type = val;
          found = true;
        }
      });

      return found;
    }

    /** Item inventory page scraping logic **/
    function _scrapeInst (scraper, parentInst) {
      // Only scrape items that actually can be scraped. If the item has no inventory, then
      // we have hit a leaf node.
      if (parentInst.commonItem.invUrl === '') return;

      // Otherwise, fetch the inventory URL, load it, and get the table we want to parse.
      // TODO: cache the htmltext by item ID to reduce calls to bricklink, add updatecache scrape option
      const htmlText = UrlFetchApp.fetch(parentInst.commonItem.invUrl).getContentText();
      const $ = Cheerio.load(htmlText);
      // TODO: check the revision of the inventory against the cached copy.    
      const $tr = $(`form[action*=${parentInst.commonItem.num}] > table.ta > tbody`).children('tr');
      
      // If the format of the page does not represent a valid inventory, assume a leaf node and return
      // There needs to be at least four rows for a valid inventory: Header, Section, Type, and one item.
      // The first header row, should have seven columns as defined in BrickTypes.inventoryColumns
      const numCols = $tr.first().children('*').length; 
      const numRows = $tr.length;
      if (numCols !== 7) return;
      if (numRows < 4) return;
      
      // Track the current section and type as we parse the table. There shouldn't be any unknown items found,
      // but if there are, we won't prevent them from being added. They can be filtered out later, if needed.
      let rowLocation = {section: BrickTypes.sectionEnum.UNKNOWN, type: BrickTypes.typeEnum.UNKNOWN};

      // Start parsing the table on row 1 (skipping row 0), because we don't need the header row.
      for (let i = 1; i < numRows; i++){
        let row = $tr.eq(i);

        // Check to see if it is an item row first. We expect to generally find more of these, so
        // testing for it first speeds up scraping.
        if(_scrapeItemRow(scraper, row, rowLocation, parentInst)) continue;

        // If it's not an item row, check to see if it is a section header or type 
        // header row and update the variable.     
        if (_scrapeHeader(row, rowLocation, BrickTypes.inventorySections)) continue;
        if (_scrapeHeader(row, rowLocation, BrickTypes.inventoryItemTypes)) continue;

        // If we got here, the row was not an item or any known kind of header
        throw `Unexpected row format on row ${i} for "${parentInst.commonItem.invUrl}" ${row.html()}`
      }
    }
  }
} /** End BrickScraper **/
